/**
 * SERVICIO DE WAZUH UNIFICADO
 *
 * Consolida toda la funcionalidad de integraci√≥n con Wazuh:
 * - Autenticaci√≥n con API Wazuh
 * - Gesti√≥n de grupos para empresas
 * - Sincronizaci√≥n autom√°tica
 * - Cache inteligente de tokens
 * - Gesti√≥n de agentes y vulnerabilidades
 */

const { execSync } = require('child_process');
const { get } = require('../config/environment');
const { createError, ErrorTypes } = require('../middleware/errorHandler');

/**
 * Clase principal del servicio Wazuh
 *
 * ¬øQu√© hace? Centraliza toda la interacci√≥n con Wazuh
 * ¬øPor qu√©? Elimina duplicaci√≥n y mejora mantenibilidad
 * ¬øPara qu√©? Gesti√≥n consistente de agentes y grupos
 */
class WazuhService {
  constructor(databaseService) {
    this.db = databaseService;
    this.tokenCache = {
      token: null,
      expires: null
    };
    
    // Configuraci√≥n desde variables de entorno
    this.config = {
      apiUrl: get('wazuh.apiUrl'),
      username: get('wazuh.username'),
      password: get('wazuh.password'),
      sslVerify: get('wazuh.sslVerify'),
      timeout: get('wazuh.timeout'),
      retryAttempts: get('wazuh.retryAttempts'),
      rateLimit: get('wazuh.rateLimit')
    };

    console.log('üîß WazuhService inicializado');
    console.log(`   API URL: ${this.config.apiUrl}`);
    console.log(`   SSL Verify: ${this.config.sslVerify}`);
  }

  /**
   * Obtener token de autenticaci√≥n Wazuh con cache inteligente
   *
   * ¬øQu√© hace? Gestiona autenticaci√≥n con cache autom√°tico
   * ¬øPor qu√©? Evita llamadas innecesarias a la API
   * ¬øPara qu√©? Mejor rendimiento y menos carga en Wazuh
   */
  async getAuthToken() {
    try {
      // Verificar cache v√°lido
      if (this.tokenCache.token && 
          this.tokenCache.expires && 
          new Date() < this.tokenCache.expires) {
        return this.tokenCache.token;
      }

      console.log('üîê Obteniendo nuevo token de Wazuh...');

      const auth = Buffer.from(`${this.config.username}:${this.config.password}`).toString('base64');
      
      const response = await fetch(`${this.config.apiUrl}/security/user/authenticate`, {
        method: 'POST',
        headers: {
          'Authorization': `Basic ${auth}`,
          'Content-Type': 'application/json'
        },
        timeout: this.config.timeout
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      
      if (!data || !data.data || !data.data.token) {
        throw new Error('Respuesta inv√°lida de Wazuh API');
      }

      // Cache token con 15 minutos de validez
      this.tokenCache.token = data.data.token;
      this.tokenCache.expires = new Date(Date.now() + 15 * 60 * 1000);

      console.log('‚úÖ Token de Wazuh obtenido exitosamente');
      return this.tokenCache.token;

    } catch (error) {
      console.error('‚ùå Error obteniendo token de Wazuh:', error.message);
      this.tokenCache.token = null;
      this.tokenCache.expires = null;
      throw createError(
        'Error conectando con Wazuh API',
        503,
        ErrorTypes.EXTERNAL_SERVICE,
        { service: 'wazuh', operation: 'authenticate', error: error.message }
      );
    }
  }

  /**
   * Realizar llamada a API Wazuh con reintentos autom√°ticos
   *
   * ¬øQu√© hace? Wrapper para todas las llamadas a Wazuh API
   * ¬øPor qu√©? Manejo consistente de errores y reintentos
   * ¬øPara qu√©? Robustez en la comunicaci√≥n con Wazuh
   */
  async apiCall(endpoint, method = 'GET', body = null) {
    let lastError;
    
    for (let attempt = 1; attempt <= this.config.retryAttempts; attempt++) {
      try {
        const token = await this.getAuthToken();
        
        const options = {
          method: method,
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          timeout: this.config.timeout
        };

        if (body && method !== 'GET') {
          options.body = JSON.stringify(body);
        }

        const response = await fetch(`${this.config.apiUrl}${endpoint}`, options);

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        return data;

      } catch (error) {
        lastError = error;
        console.warn(`‚ö†Ô∏è Intento ${attempt}/${this.config.retryAttempts} fall√≥:`, error.message);
        
        if (attempt < this.config.retryAttempts) {
          // Esperar antes del siguiente intento (backoff exponencial)
          await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
        }
      }
    }

    // Todos los intentos fallaron
    throw createError(
      `Error en API Wazuh despu√©s de ${this.config.retryAttempts} intentos`,
      503,
      ErrorTypes.EXTERNAL_SERVICE,
      { 
        service: 'wazuh', 
        endpoint: endpoint, 
        method: method, 
        lastError: lastError.message 
      }
    );
  }

  /**
   * Crear grupo Wazuh para empresa
   *
   * ¬øQu√© hace? Crea grupos de agentes para empresas espec√≠ficas
   * ¬øPor qu√©? Organizaci√≥n multi-tenant de agentes
   * ¬øPara qu√©? Separaci√≥n de datos entre empresas
   */
  async createCompanyGroup(tenantId, companyName) {
    try {
      const groupName = `zs_${tenantId}`;
      console.log(`üèóÔ∏è Creando grupo Wazuh: ${groupName} para ${companyName}`);

      // Usar comando local de Wazuh para crear grupo
      const command = `sudo /var/ossec/bin/agent_groups -a -g ${groupName} -q`;
      
      try {
        const output = execSync(command, { 
          encoding: 'utf8',
          timeout: 10000 // 10 segundos timeout
        });
        
        console.log(`‚úÖ Grupo ${groupName} creado exitosamente`);
        return { success: true, groupName: groupName };
        
      } catch (execError) {
        // Verificar si el error es porque el grupo ya existe
        if (execError.message.includes('already exists') || 
            execError.stderr && execError.stderr.includes('already exists')) {
          console.log(`‚ÑπÔ∏è Grupo ${groupName} ya existe`);
          return { success: true, groupName: groupName, existed: true };
        } else {
          throw execError;
        }
      }

    } catch (error) {
      console.error(`‚ùå Error creando grupo para ${companyName}:`, error.message);
      throw createError(
        `Error creando grupo Wazuh para empresa`,
        500,
        ErrorTypes.EXTERNAL_SERVICE,
        { 
          service: 'wazuh', 
          operation: 'create_group', 
          tenantId: tenantId,
          error: error.message 
        }
      );
    }
  }

  /**
   * Sincronizar empresa con Wazuh
   *
   * ¬øQu√© hace? Crea grupo y actualiza BD si es necesario
   * ¬øPor qu√©? Mantener sincronizaci√≥n entre BD y Wazuh
   * ¬øPara qu√©? Consistencia de datos multi-tenant
   */
  async syncCompanyToWazuh(companyId, tenantId, companyName) {
    try {
      console.log(`üîÑ Sincronizando empresa ${companyName} con Wazuh...`);

      // 1. Crear grupo en Wazuh
      const groupResult = await this.createCompanyGroup(tenantId, companyName);
      
      if (!groupResult.success) {
        throw new Error('Error creando grupo en Wazuh');
      }

      // 2. Actualizar BD con nombre del grupo
      await this.db.query(
        'UPDATE companies SET wazuh_group = $1 WHERE id = $2',
        [groupResult.groupName, companyId]
      );

      console.log(`‚úÖ Empresa ${companyName} sincronizada con Wazuh`);
      console.log(`   Grupo: ${groupResult.groupName}`);
      console.log(`   Estado: ${groupResult.existed ? 'Ya exist√≠a' : 'Creado nuevo'}`);

      return {
        success: true,
        companyId: companyId,
        tenantId: tenantId,
        companyName: companyName,
        wazuhGroup: groupResult.groupName,
        isNewGroup: !groupResult.existed
      };

    } catch (error) {
      console.error(`‚ùå Error sincronizando empresa ${companyName}:`, error.message);
      throw error;
    }
  }

  /**
   * Sincronizar todas las empresas sin grupo Wazuh
   *
   * ¬øQu√© hace? Sincroniza masivamente todas las empresas pendientes
   * ¬øPor qu√©? Operaci√≥n de mantenimiento autom√°tica
   * ¬øPara qu√©? Asegurar que todas las empresas tienen grupo
   */
  async syncAllCompanies() {
    try {
      console.log('üåê Iniciando sincronizaci√≥n masiva con Wazuh...');

      // Obtener empresas sin grupo de Wazuh
      const result = await this.db.query(`
        SELECT id, tenant_id, name, wazuh_group 
        FROM companies 
        WHERE wazuh_group IS NULL
      `);

      if (result.rows.length === 0) {
        console.log('‚úÖ Todas las empresas ya est√°n sincronizadas');
        return {
          success: true,
          totalCompanies: 0,
          syncedCompanies: 0,
          errors: []
        };
      }

      console.log(`üìã Encontradas ${result.rows.length} empresas para sincronizar`);

      const syncResults = {
        success: true,
        totalCompanies: result.rows.length,
        syncedCompanies: 0,
        errors: []
      };

      // Procesar cada empresa
      for (const company of result.rows) {
        try {
          await this.syncCompanyToWazuh(
            company.id, 
            company.tenant_id, 
            company.name
          );
          
          syncResults.syncedCompanies++;
          
          // Peque√±a pausa entre empresas para no sobrecargar
          await new Promise(resolve => setTimeout(resolve, 1000));
          
        } catch (error) {
          console.error(`‚ùå Error sincronizando ${company.name}:`, error.message);
          syncResults.errors.push({
            companyId: company.id,
            companyName: company.name,
            error: error.message
          });
        }
      }

      // Log del resumen final
      console.log('üéâ Sincronizaci√≥n masiva completada:');
      console.log(`   Total empresas: ${syncResults.totalCompanies}`);
      console.log(`   Sincronizadas: ${syncResults.syncedCompanies}`);
      console.log(`   Errores: ${syncResults.errors.length}`);

      if (syncResults.errors.length > 0) {
        console.log('   Empresas con errores:');
        syncResults.errors.forEach(error => {
          console.log(`     - ${error.companyName}: ${error.error}`);
        });
      }

      return syncResults;

    } catch (error) {
      console.error('‚ùå Error en sincronizaci√≥n masiva:', error.message);
      throw createError(
        'Error en sincronizaci√≥n masiva con Wazuh',
        500,
        ErrorTypes.INTERNAL,
        { operation: 'sync_all_companies', error: error.message }
      );
    }
  }

  /**
   * Obtener agentes de una empresa espec√≠fica
   *
   * ¬øQu√© hace? Lista agentes asociados a un grupo de empresa
   * ¬øPor qu√©? Gesti√≥n multi-tenant de agentes
   * ¬øPara qu√©? Monitoreo y estad√≠sticas por empresa
   */
  async getCompanyAgents(wazuhGroup) {
    try {
      console.log(`üì° Obteniendo agentes del grupo: ${wazuhGroup}`);

      // Obtener todos los agentes
      const response = await this.apiCall('/agents?limit=1000');
      
      if (!response || !response.data || !response.data.affected_items) {
        return [];
      }

      // Filtrar agentes por grupo de la empresa
      const companyAgents = response.data.affected_items.filter(agent => {
        return agent.group && agent.group.includes(wazuhGroup);
      });

      console.log(`üìä Encontrados ${companyAgents.length} agentes para ${wazuhGroup}`);
      return companyAgents;

    } catch (error) {
      console.error(`‚ùå Error obteniendo agentes de ${wazuhGroup}:`, error.message);
      throw error;
    }
  }

  /**
   * Obtener estad√≠sticas de grupos Wazuh
   *
   * ¬øQu√© hace? Informaci√≥n de todos los grupos del sistema
   * ¬øPor qu√©? Monitoreo y debugging
   * ¬øPara qu√©? Dashboard administrativo
   */
  async getGroupsStats() {
    try {
      console.log('üìä Obteniendo estad√≠sticas de grupos Wazuh...');

      const response = await this.apiCall('/groups');
      
      if (!response || !response.data || !response.data.affected_items) {
        return [];
      }

      return response.data.affected_items;

    } catch (error) {
      console.error('‚ùå Error obteniendo estad√≠sticas de grupos:', error.message);
      throw error;
    }
  }

  /**
   * Health check del servicio Wazuh
   *
   * ¬øQu√© hace? Verifica conectividad y estado de Wazuh
   * ¬øPor qu√©? Monitoreo de servicios externos
   * ¬øPara qu√©? Alertas y diagn√≥sticos
   */
  async healthCheck() {
    try {
      console.log('‚ù§Ô∏è Verificando salud del servicio Wazuh...');

      const startTime = Date.now();
      const response = await this.apiCall('/');
      const responseTime = Date.now() - startTime;

      return {
        status: 'healthy',
        responseTime: responseTime,
        apiUrl: this.config.apiUrl,
        tokenCached: !!this.tokenCache.token,
        tokenExpires: this.tokenCache.expires ? this.tokenCache.expires.toISOString() : null,
        wazuhVersion: response?.data?.api_version || 'unknown',
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error('‚ùå Health check de Wazuh fall√≥:', error.message);
      return {
        status: 'unhealthy',
        error: error.message,
        apiUrl: this.config.apiUrl,
        timestamp: new Date().toISOString()
      };
    }
  }


  /**
   * Limpiar cache de tokens (√∫til para testing)
   */
  clearTokenCache() {
    console.log('üßπ Limpiando cache de tokens Wazuh');
    this.tokenCache.token = null;
    this.tokenCache.expires = null;
  }
}

module.exports = WazuhService;