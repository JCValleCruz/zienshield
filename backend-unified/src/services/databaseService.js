/**
 * SERVICIO DE BASE DE DATOS UNIFICADO
 * 
 * Gestiona todas las conexiones y operaciones con PostgreSQL:
 * - Pool de conexiones optimizado
 * - Manejo robusto de errores de BD
 * - M√©todos reutilizables para queries comunes
 * - Soporte para transacciones
 * - Logs detallados para monitoring
 */

const { Pool } = require('pg');
const { get } = require('../config/environment');

/**
 * Clase principal del servicio de base de datos
 * 
 * ¬øQu√© hace? Gestiona todas las operaciones con PostgreSQL de forma centralizada
 * ¬øPor qu√© una clase? Permite mantener estado del pool y m√©todos organizados
 * ¬øPara qu√©? Eliminar duplicaci√≥n de c√≥digo de BD entre backends
 */
class DatabaseService {
  constructor() {
    this.pool = null;
    this.isConnected = false;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = get('database.maxReconnectAttempts') || 5;
    
    console.log('üóÑÔ∏è DatabaseService inicializando...');
  }

  /**
   * Inicializar pool de conexiones PostgreSQL
   * 
   * ¬øQu√© hace? Configura el pool de conexiones con la configuraci√≥n del environment
   * ¬øPor qu√© un pool? Para reutilizar conexiones y mejorar performance
   * ¬øPara qu√©? Conexiones eficientes sin overhead de crear/cerrar constantemente
   */
  async initialize() {
    try {
      console.log('üîå Configurando pool de conexiones PostgreSQL...');
      
      // Configuraci√≥n del pool desde environment.js
      const poolConfig = {
        host: get('database.host'),
        port: get('database.port'),
        database: get('database.database'),
        user: get('database.username'),
        password: get('database.password'),
        
        // Configuraci√≥n del pool
        min: get('database.pool.min') || 2,           // M√≠nimo 2 conexiones activas
        max: get('database.pool.max') || 10,          // M√°ximo 10 conexiones
        idleTimeoutMillis: get('database.pool.idleTimeout') || 30000, // 30s timeout
        connectionTimeoutMillis: get('database.pool.connectionTimeout') || 5000, // 5s para conectar
        
        // Configuraci√≥n SSL (importante para producci√≥n)
        ssl: get('database.ssl') ? {
          rejectUnauthorized: false // Para certificados autofirmados
        } : false,
        
        // Configuraci√≥n adicional
        statement_timeout: 60000,   // 60s timeout para queries
        query_timeout: 30000,       // 30s timeout por query individual
        application_name: 'ZienSHIELD-Backend-Unified'
      };

      // Crear pool
      this.pool = new Pool(poolConfig);
      
      // Event listeners para monitoring
      this.pool.on('connect', (client) => {
        console.log('‚úÖ Nueva conexi√≥n PostgreSQL establecida');
      });
      
      this.pool.on('acquire', (client) => {
        console.log('üîÑ Conexi√≥n PostgreSQL adquirida del pool');
      });
      
      this.pool.on('error', (err, client) => {
        console.error('‚ùå Error en pool PostgreSQL:', err);
        this.handlePoolError(err);
      });
      
      this.pool.on('remove', (client) => {
        console.log('üóëÔ∏è Conexi√≥n PostgreSQL removida del pool');
      });

      // Test de conexi√≥n inicial
      await this.testConnection();
      
      this.isConnected = true;
      this.reconnectAttempts = 0;
      
      console.log('üéâ DatabaseService inicializado correctamente');
      console.log(`üìä Pool configurado: min=${poolConfig.min}, max=${poolConfig.max}, host=${poolConfig.host}:${poolConfig.port}/${poolConfig.database}`);
      
    } catch (error) {
      console.error('‚ùå Error inicializando DatabaseService:', error);
      throw new Error(`No se pudo conectar a la base de datos: ${error.message}`);
    }
  }

  /**
   * Test de conexi√≥n a la base de datos
   * 
   * ¬øQu√© hace? Verifica que la conexi√≥n funcione ejecutando una query simple
   * ¬øPor qu√©? Para detectar problemas de conectividad temprano
   * ¬øPara qu√©? Evitar errores en runtime por problemas de BD
   */
  async testConnection() {
    console.log('üß™ Probando conexi√≥n a PostgreSQL...');
    
    try {
      const client = await this.pool.connect();
      
      // Query simple para probar conectividad
      const result = await client.query('SELECT NOW() as current_time, version() as pg_version');
      const { current_time, pg_version } = result.rows[0];
      
      console.log('‚úÖ Conexi√≥n PostgreSQL exitosa:');
      console.log(`   üìÖ Tiempo servidor: ${current_time}`);
      console.log(`   üêò Versi√≥n PostgreSQL: ${pg_version.split(' ')[0]} ${pg_version.split(' ')[1]}`);
      
      // Verificar que existe la tabla companies
      const tableCheck = await client.query(`
        SELECT EXISTS (
          SELECT FROM information_schema.tables 
          WHERE table_schema = 'public' 
          AND table_name = 'companies'
        ) as table_exists
      `);
      
      if (tableCheck.rows[0].table_exists) {
        console.log('‚úÖ Tabla "companies" encontrada en la base de datos');
      } else {
        console.warn('‚ö†Ô∏è Tabla "companies" no encontrada - puede necesitarse migraci√≥n');
      }
      
      client.release();
      
    } catch (error) {
      console.error('‚ùå Error en test de conexi√≥n:', error);
      throw error;
    }
  }

  /**
   * Ejecutar query SQL con manejo de errores robusto
   * 
   * ¬øQu√© hace? M√©todo principal para ejecutar cualquier query SQL
   * ¬øPor qu√© centralizado? Para logging uniforme y manejo de errores consistente
   * ¬øPara qu√©? Un punto de entrada para todas las operaciones de BD
   */
  async query(text, params = []) {
    // Validar que el servicio est√© inicializado
    if (!this.pool || !this.isConnected) {
      throw new Error('DatabaseService no est√° inicializado. Llama a initialize() primero.');
    }

    const start = Date.now();
    let client;
    
    try {
      // Log de la query (sin par√°metros sensibles)
      console.log('üîç Ejecutando query:', {
        sql: text.replace(/\s+/g, ' ').trim().substring(0, 100) + (text.length > 100 ? '...' : ''),
        paramCount: params.length,
        timestamp: new Date().toISOString()
      });
      
      // Obtener conexi√≥n del pool
      client = await this.pool.connect();
      
      // Ejecutar query
      const result = await client.query(text, params);
      
      const duration = Date.now() - start;
      
      // Log del resultado
      console.log('‚úÖ Query ejecutada exitosamente:', {
        rowsAffected: result.rowCount,
        rowsReturned: result.rows?.length || 0,
        duration: `${duration}ms`,
        command: result.command
      });
      
      return result;
      
    } catch (error) {
      const duration = Date.now() - start;
      
      // Log detallado del error
      console.error('‚ùå Error ejecutando query:', {
        error: error.message,
        code: error.code,
        detail: error.detail,
        hint: error.hint,
        position: error.position,
        duration: `${duration}ms`,
        sql: text.substring(0, 200),
        paramCount: params.length
      });
      
      // Re-lanzar con informaci√≥n adicional
      const enhancedError = new Error(`Database query failed: ${error.message}`);
      enhancedError.code = error.code;
      enhancedError.detail = error.detail;
      enhancedError.hint = error.hint;
      enhancedError.originalError = error;
      
      throw enhancedError;
      
    } finally {
      // Siempre liberar la conexi√≥n
      if (client) {
        client.release();
      }
    }
  }

  /**
   * Ejecutar m√∫ltiples queries en una transacci√≥n
   * 
   * ¬øQu√© hace? Permite ejecutar varias queries como una unidad at√≥mica
   * ¬øPor qu√©? Para operaciones que requieren consistencia (todo o nada)
   * ¬øPara qu√©? Operaciones complejas como crear empresa + usuario inicial
   */
  async transaction(callback) {
    if (!this.pool || !this.isConnected) {
      throw new Error('DatabaseService no est√° inicializado. Llama a initialize() primero.');
    }

    let client;
    
    try {
      console.log('üîÑ Iniciando transacci√≥n...');
      
      client = await this.pool.connect();
      
      // Iniciar transacci√≥n
      await client.query('BEGIN');
      
      // Ejecutar callback con el cliente transaccional
      const result = await callback(client);
      
      // Commit si todo sali√≥ bien
      await client.query('COMMIT');
      
      console.log('‚úÖ Transacci√≥n completada exitosamente');
      
      return result;
      
    } catch (error) {
      console.error('‚ùå Error en transacci√≥n, haciendo ROLLBACK:', error);
      
      // Rollback en caso de error
      if (client) {
        try {
          await client.query('ROLLBACK');
          console.log('üîÑ ROLLBACK completado');
        } catch (rollbackError) {
          console.error('‚ùå Error haciendo ROLLBACK:', rollbackError);
        }
      }
      
      throw error;
      
    } finally {
      if (client) {
        client.release();
      }
    }
  }

  /**
   * Obtener estad√≠sticas del pool de conexiones
   * 
   * ¬øQu√© hace? Proporciona informaci√≥n sobre el estado del pool
   * ¬øPor qu√©? Para monitoring y debugging de performance
   * ¬øPara qu√©? Detectar problemas de conexiones y optimizar configuraci√≥n
   */
  getPoolStats() {
    if (!this.pool) {
      return { error: 'Pool no inicializado' };
    }
    
    return {
      totalCount: this.pool.totalCount,      // Total conexiones creadas
      idleCount: this.pool.idleCount,        // Conexiones disponibles
      waitingCount: this.pool.waitingCount,  // Clientes esperando conexi√≥n
      isConnected: this.isConnected,
      maxConnections: this.pool.options.max,
      minConnections: this.pool.options.min
    };
  }

  /**
   * M√©todo para cerrar graciosamente todas las conexiones
   * 
   * ¬øQu√© hace? Cierra el pool y todas las conexiones de forma ordenada
   * ¬øPor qu√©? Para evitar conexiones colgadas al cerrar la aplicaci√≥n
   * ¬øPara qu√©? Shutdown limpio de la aplicaci√≥n
   */
  async close() {
    if (this.pool) {
      console.log('üîå Cerrando pool de conexiones PostgreSQL...');
      
      try {
        await this.pool.end();
        this.isConnected = false;
        console.log('‚úÖ Pool PostgreSQL cerrado correctamente');
      } catch (error) {
        console.error('‚ùå Error cerrando pool PostgreSQL:', error);
      }
    }
  }

  /**
   * Manejar errores del pool de conexiones
   * 
   * ¬øQu√© hace? Gestiona errores de conectividad y reconexi√≥n autom√°tica
   * ¬øPor qu√©? Para recuperarse de ca√≠das temporales de BD
   * ¬øPara qu√©? Mantener el servicio funcionando ante problemas de red
   */
  async handlePoolError(error) {
    console.error('üö® Error en pool de conexiones:', error);
    
    this.isConnected = false;
    
    // Si es un error de conectividad, intentar reconectar
    if (error.code === 'ECONNREFUSED' || 
        error.code === 'ENOTFOUND' || 
        error.code === 'ETIMEDOUT') {
      
      if (this.reconnectAttempts < this.maxReconnectAttempts) {
        this.reconnectAttempts++;
        const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000); // Exponential backoff
        
        console.log(`üîÑ Intentando reconectar en ${delay}ms (intento ${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);
        
        setTimeout(async () => {
          try {
            await this.testConnection();
            this.isConnected = true;
            this.reconnectAttempts = 0;
            console.log('‚úÖ Reconexi√≥n exitosa');
          } catch (reconnectError) {
            console.error('‚ùå Fallo en reconexi√≥n:', reconnectError);
          }
        }, delay);
      } else {
        console.error('üíÄ M√°ximo n√∫mero de intentos de reconexi√≥n alcanzado');
      }
    }
  }

  /**
   * Ejecutar queries preparadas para mejor performance
   * 
   * ¬øQu√© hace? Usa prepared statements para queries frecuentes
   * ¬øPor qu√©? Mejor performance y seguridad contra SQL injection
   * ¬øPara qu√©? Operaciones repetitivas como buscar empresas por ID
   */
  async preparedQuery(name, text, params = []) {
    if (!this.pool || !this.isConnected) {
      throw new Error('DatabaseService no est√° inicializado. Llama a initialize() primero.');
    }

    let client;
    
    try {
      client = await this.pool.connect();
      
      // Usar prepared statement
      const result = await client.query({
        name: name,
        text: text,
        values: params
      });
      
      return result;
      
    } catch (error) {
      console.error(`‚ùå Error en prepared query "${name}":`, error);
      throw error;
    } finally {
      if (client) {
        client.release();
      }
    }
  }

  /**
   * Health check espec√≠fico para la base de datos
   * 
   * ¬øQu√© hace? Verifica que la BD est√© respondiendo correctamente
   * ¬øPor qu√©? Para endpoints de monitoreo y health checks
   * ¬øPara qu√©? Detectar problemas de BD desde el exterior
   */
  async healthCheck() {
    try {
      const start = Date.now();
      
      // Query simple pero efectiva
      const result = await this.query('SELECT 1 as health_check');
      
      const responseTime = Date.now() - start;
      const stats = this.getPoolStats();
      
      return {
        status: 'healthy',
        responseTime: `${responseTime}ms`,
        pool: stats,
        timestamp: new Date().toISOString(),
        database: {
          connected: this.isConnected,
          host: get('database.host'),
          port: get('database.port'),
          database: get('database.name')
        }
      };
      
    } catch (error) {
      return {
        status: 'unhealthy',
        error: error.message,
        pool: this.getPoolStats(),
        timestamp: new Date().toISOString(),
        database: {
          connected: false,
          host: get('database.host'),
          port: get('database.port'),
          database: get('database.name')
        }
      };
    }
  }
}

// Instancia singleton del servicio
let databaseServiceInstance = null;

/**
 * Obtener instancia singleton del DatabaseService
 * 
 * ¬øQu√© hace? Garantiza que solo haya una instancia del servicio en toda la app
 * ¬øPor qu√© singleton? Un pool de conexiones debe ser √∫nico por aplicaci√≥n
 * ¬øPara qu√©? Evitar m√∫ltiples pools y problemas de recursos
 */
function getDatabaseService() {
  if (!databaseServiceInstance) {
    databaseServiceInstance = new DatabaseService();
  }
  
  return databaseServiceInstance;
}

module.exports = {
  DatabaseService,
  getDatabaseService
};