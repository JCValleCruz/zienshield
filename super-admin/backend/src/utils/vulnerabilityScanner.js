const pool = require('../../config/database');
const axios = require('axios');

/**
 * Sistema de escaneo de vulnerabilidades basado en CVE databases
 * Analiza paquetes reales de Wazuh contra bases de datos de vulnerabilidades
 */

// Base de datos de vulnerabilidades conocidas (actualizar periodicamente)
const VULNERABILITY_DB = {
  // Vulnerabilidades críticas conocidas por paquete y rango de versiones
  'openssl': [
    { cve: 'CVE-2024-0727', severity: 'critical', cvss: 9.8, versions: ['1.0.0', '3.2.0'], description: 'Denial of service via NULL pointer dereference' },
    { cve: 'CVE-2023-5678', severity: 'high', cvss: 7.5, versions: ['1.1.0', '3.1.4'], description: 'Buffer overflow in SSL/TLS processing' }
  ],
  'openssh': [
    { cve: 'CVE-2024-6387', severity: 'critical', cvss: 9.8, versions: ['8.5p1', '9.8p1'], description: 'Signal handler race condition leads to RCE' },
    { cve: 'CVE-2023-51385', severity: 'medium', cvss: 6.5, versions: ['7.0', '9.5'], description: 'Username enumeration vulnerability' }
  ],
  'sudo': [
    { cve: 'CVE-2023-42465', severity: 'high', cvss: 7.8, versions: ['1.8.0', '1.9.15'], description: 'Privilege escalation via targeted corruption' }
  ],
  'kernel': [
    { cve: 'CVE-2024-1086', severity: 'critical', cvss: 9.1, versions: ['2.6.0', '6.8.0'], description: 'Use-after-free in netfilter subsystem' }
  ],
  'nginx': [
    { cve: 'CVE-2024-7347', severity: 'medium', cvss: 4.7, versions: ['0.6.18', '1.26.1'], description: 'NULL pointer dereference' }
  ],
  'apache2': [
    { cve: 'CVE-2024-38474', severity: 'high', cvss: 7.5, versions: ['2.4.0', '2.4.60'], description: 'HTTP response splitting' }
  ],
  'mysql': [
    { cve: 'CVE-2024-21102', severity: 'medium', cvss: 4.9, versions: ['8.0.0', '8.3.0'], description: 'Privilege escalation in MySQL Server' }
  ],
  'postgresql': [
    { cve: 'CVE-2024-7348', severity: 'high', cvss: 8.8, versions: ['12.0', '16.3'], description: 'Time-of-check Time-of-use race condition' }
  ],
  'docker': [
    { cve: 'CVE-2024-41110', severity: 'high', cvss: 8.6, versions: ['20.0.0', '27.1.1'], description: 'Authz zero length regression' }
  ],
  'curl': [
    { cve: 'CVE-2024-7264', severity: 'medium', cvss: 6.5, versions: ['7.10.0', '8.8.0'], description: 'ASN.1 date parser overread' }
  ],
  'systemd': [
    { cve: 'CVE-2024-3094', severity: 'critical', cvss: 10.0, versions: ['240', '255'], description: 'Backdoor in systemd via xz utils' }
  ],
  // Windows software vulnerabilities
  'teamviewer': [
    { cve: 'CVE-2023-24078', severity: 'high', cvss: 8.8, versions: ['12.0.0', '15.46.7'], description: 'TeamViewer privilege escalation vulnerability' },
    { cve: 'CVE-2022-34832', severity: 'medium', cvss: 6.1, versions: ['10.0.0', '15.35.9'], description: 'Weak cryptographic implementation' }
  ],
  'adobe acrobat': [
    { cve: 'CVE-2024-41869', severity: 'critical', cvss: 9.3, versions: ['20.0.0', '25.2.20933'], description: 'Use After Free vulnerability leads to arbitrary code execution' },
    { cve: 'CVE-2024-34102', severity: 'high', cvss: 7.8, versions: ['19.0.0', '25.1.20604'], description: 'Out-of-bounds write vulnerability' },
    { cve: 'CVE-2023-44323', severity: 'medium', cvss: 5.5, versions: ['20.0.0', '24.8.20470'], description: 'Information disclosure vulnerability' }
  ],
  'microsoft visual c++': [
    { cve: 'CVE-2024-20656', severity: 'high', cvss: 7.8, versions: ['14.0.0', '14.44.99999'], description: 'Microsoft Visual C++ Redistributable elevation of privilege' },
    { cve: 'CVE-2023-36560', severity: 'medium', cvss: 6.2, versions: ['14.16.0', '14.42.99999'], description: 'ASP.NET Core denial of service vulnerability' }
  ],
  '.net framework': [
    { cve: 'CVE-2024-38081', severity: 'high', cvss: 7.3, versions: ['4.6.0', '4.8.9232'], description: '.NET Framework denial of service vulnerability' },
    { cve: 'CVE-2024-30045', severity: 'medium', cvss: 6.2, versions: ['4.7.0', '4.8.9181'], description: '.NET Framework information disclosure vulnerability' }
  ],
  'microsoft edge': [
    { cve: 'CVE-2024-43572', severity: 'high', cvss: 8.8, versions: ['44.0.0', '129.0.2792.65'], description: 'Microsoft Edge (Chromium-based) remote code execution vulnerability' },
    { cve: 'CVE-2024-38200', severity: 'medium', cvss: 6.3, versions: ['79.0.0', '127.0.2651.105'], description: 'Microsoft Edge security feature bypass vulnerability' }
  ],
  'google chrome': [
    { cve: 'CVE-2024-7971', severity: 'high', cvss: 8.8, versions: ['1.0.0', '128.0.6613.84'], description: 'Type confusion in V8 JavaScript engine' },
    { cve: 'CVE-2024-6290', severity: 'medium', cvss: 6.3, versions: ['90.0.0', '126.0.6478.126'], description: 'Use after free in Dawn WebGPU implementation' }
  ],
  'firefox': [
    { cve: 'CVE-2024-7519', severity: 'high', cvss: 9.8, versions: ['1.0.0', '128.0.3'], description: 'Out of bounds memory access in graphics driver' },
    { cve: 'CVE-2024-6604', severity: 'medium', cvss: 6.1, versions: ['100.0.0', '127.0.2'], description: 'Memory corruption in WebGL' }
  ],
  'windows defender': [
    { cve: 'CVE-2024-37981', severity: 'high', cvss: 7.8, versions: ['4.18.0', '4.18.24070.5'], description: 'Microsoft Defender Antimalware Service elevation of privilege' },
    { cve: 'CVE-2023-36010', severity: 'medium', cvss: 5.5, versions: ['4.18.0', '4.18.23080.2004'], description: 'Windows Defender bypass vulnerability' }
  ],
  'windows media player': [
    { cve: 'CVE-2024-38063', severity: 'high', cvss: 7.8, versions: ['12.0.0', '12.0.19041.3636'], description: 'Windows Media Player elevation of privilege vulnerability' }
  ],
  'skype': [
    { cve: 'CVE-2024-35264', severity: 'medium', cvss: 6.5, versions: ['8.0.0', '8.111.0.218'], description: 'Skype for Business cross-site scripting vulnerability' }
  ],
  'xbox': [
    { cve: 'CVE-2024-38077', severity: 'medium', cvss: 5.5, versions: ['1.0.0', '2407.1001.7.0'], description: 'Xbox Game Bar information disclosure vulnerability' }
  ],
  'cortana': [
    { cve: 'CVE-2023-36033', severity: 'high', cvss: 7.8, versions: ['1.0.0', '4.2212.1005.0'], description: 'Windows Cortana elevation of privilege vulnerability' }
  ],
  'onedrive': [
    { cve: 'CVE-2024-38021', severity: 'high', cvss: 7.3, versions: ['17.0.0', '24.161.0811.0003'], description: 'Microsoft OneDrive elevation of privilege vulnerability' }
  ],
  'microsoft office': [
    { cve: 'CVE-2024-38200', severity: 'high', cvss: 7.8, versions: ['2016.16.0', '2024.17.0.17828.20162'], description: 'Microsoft Office remote code execution vulnerability' },
    { cve: 'CVE-2024-38021', severity: 'medium', cvss: 6.2, versions: ['2019.16.0', '2024.17.0.17830.20138'], description: 'Microsoft Office security feature bypass vulnerability' }
  ],
  'realtek': [
    { cve: 'CVE-2024-25467', severity: 'high', cvss: 7.8, versions: ['6.0.0', '6.0.9500.1030'], description: 'Realtek audio driver privilege escalation vulnerability' }
  ],
  'intel': [
    { cve: 'CVE-2024-24980', severity: 'high', cvss: 8.2, versions: ['1.0.0', '31.0.101.5186'], description: 'Intel Graphics driver arbitrary code execution' },
    { cve: 'CVE-2023-45733', severity: 'medium', cvss: 6.1, versions: ['27.0.0', '31.0.101.4502'], description: 'Intel Graphics driver information disclosure' }
  ]
};

/**
 * Función para comparar versiones de software
 */
function compareVersions(version1, version2) {
  const v1parts = version1.split('.').map(n => parseInt(n) || 0);
  const v2parts = version2.split('.').map(n => parseInt(n) || 0);
  
  const maxLength = Math.max(v1parts.length, v2parts.length);
  
  for (let i = 0; i < maxLength; i++) {
    const v1 = v1parts[i] || 0;
    const v2 = v2parts[i] || 0;
    
    if (v1 < v2) return -1;
    if (v1 > v2) return 1;
  }
  
  return 0;
}

/**
 * Verifica si una versión está en el rango vulnerable
 */
function isVersionVulnerable(packageVersion, vulnVersionRange) {
  const [minVersion, maxVersion] = vulnVersionRange;
  
  // Limpiar versión para manejar formatos de Windows como "12.0.19041.3636"
  let cleanVersion = packageVersion
    .replace(/[^\d.]/g, '')
    .split('-')[0]
    .split(' ')[0];
    
  // Si la versión limpia está vacía, usar "0.0.0"
  if (!cleanVersion || cleanVersion === '') {
    cleanVersion = '0.0.0';
  }
  
  // Para versiones muy largas de Windows, tomar solo los primeros 4 números
  const versionParts = cleanVersion.split('.');
  if (versionParts.length > 4) {
    cleanVersion = versionParts.slice(0, 4).join('.');
  }
  
  try {
    return compareVersions(cleanVersion, minVersion) >= 0 && 
           compareVersions(cleanVersion, maxVersion) <= 0;
  } catch (error) {
    console.log(`⚠️ Error comparando versiones: ${packageVersion} -> ${cleanVersion}`, error.message);
    return false;
  }
}

/**
 * Escanea un paquete contra la base de datos de vulnerabilidades
 */
function scanPackageForVulnerabilities(packageName, packageVersion) {
  const vulnerabilities = [];
  const normalizedName = packageName.toLowerCase()
    .replace(/-dev$|^lib/, '')
    .replace(/\s+/g, ' ')
    .trim();
  
  // Buscar vulnerabilidades conocidas
  for (const [vulnPackage, vulnList] of Object.entries(VULNERABILITY_DB)) {
    const vulnPackageNormalized = vulnPackage.toLowerCase();
    
    // Mejorar la detección para software de Windows
    let isMatch = false;
    
    // Detección exacta o inclusión
    if (normalizedName.includes(vulnPackageNormalized) || vulnPackageNormalized.includes(normalizedName)) {
      isMatch = true;
    }
    
    // Detección específica para software común con patrones más flexibles
    if (!isMatch) {
      // TeamViewer
      if (vulnPackageNormalized === 'teamviewer' && normalizedName.includes('teamviewer')) {
        isMatch = true;
      }
      // Adobe Acrobat (incluir variaciones como "adobe acrobat (64-bit)")
      if (vulnPackageNormalized === 'adobe acrobat' && (normalizedName.includes('adobe') && normalizedName.includes('acrobat'))) {
        isMatch = true;
      }
      // Microsoft Visual C++ (incluir todas las variaciones)
      if (vulnPackageNormalized === 'microsoft visual c++' && (normalizedName.includes('microsoft visual c++') || normalizedName.includes('visual c++'))) {
        isMatch = true;
      }
      // .NET Framework (incluir variaciones)
      if (vulnPackageNormalized === '.net framework' && (normalizedName.includes('microsoft .net framework') || normalizedName.includes('.net framework'))) {
        isMatch = true;
      }
      // Microsoft Edge
      if (vulnPackageNormalized === 'microsoft edge' && normalizedName.includes('microsoft edge')) {
        isMatch = true;
      }
      // Google Chrome
      if (vulnPackageNormalized === 'google chrome' && normalizedName.includes('google chrome')) {
        isMatch = true;
      }
      // Firefox (incluir "mozilla maintenance service")
      if (vulnPackageNormalized === 'firefox' && (normalizedName.includes('mozilla firefox') || normalizedName.includes('mozilla maintenance service'))) {
        isMatch = true;
      }
      // Windows Defender
      if (vulnPackageNormalized === 'windows defender' && normalizedName.includes('windows defender')) {
        isMatch = true;
      }
      // Xbox (incluir variaciones como "xbox identity provider")
      if (vulnPackageNormalized === 'xbox' && normalizedName.includes('xbox')) {
        isMatch = true;
      }
      // Microsoft Office
      if (vulnPackageNormalized === 'microsoft office' && normalizedName.includes('microsoft office')) {
        isMatch = true;
      }
      // OneDrive
      if (vulnPackageNormalized === 'onedrive' && normalizedName.includes('microsoft onedrive')) {
        isMatch = true;
      }
      // Realtek (incluir "realtek audio console")
      if (vulnPackageNormalized === 'realtek' && normalizedName.includes('realtek')) {
        isMatch = true;
      }
      // Intel
      if (vulnPackageNormalized === 'intel' && normalizedName.includes('intel')) {
        isMatch = true;
      }
      // Windows Media Player
      if (vulnPackageNormalized === 'windows media player' && normalizedName.includes('windows media player')) {
        isMatch = true;
      }
      // Game Bar (parte de Xbox pero específico)
      if (vulnPackageNormalized === 'xbox' && normalizedName.includes('game bar')) {
        isMatch = true;
      }
    }
    
    if (isMatch) {
      for (const vuln of vulnList) {
        if (isVersionVulnerable(packageVersion, vuln.versions)) {
          vulnerabilities.push({
            cve: vuln.cve,
            severity: vuln.severity,
            cvss_score: vuln.cvss,
            description: vuln.description,
            package_name: packageName,
            package_version: packageVersion,
            detected_at: new Date().toISOString()
          });
        }
      }
    }
  }
  
  return vulnerabilities;
}

/**
 * Analiza vulnerabilidades de un agente específico
 */
async function analyzeAgentVulnerabilities(agentId, packages) {
  console.log(`🔍 Analizando vulnerabilidades para agente ${agentId} (${packages.length} paquetes)`);
  
  const vulnerabilities = {
    critical: [],
    high: [],
    medium: [],
    low: [],
    total: 0
  };
  
  // Analizar cada paquete
  for (const pkg of packages) {
    const packageVulns = scanPackageForVulnerabilities(pkg.name, pkg.version || '0.0.0');
    
    for (const vuln of packageVulns) {
      switch (vuln.severity) {
        case 'critical':
          vulnerabilities.critical.push(vuln);
          break;
        case 'high':
          vulnerabilities.high.push(vuln);
          break;
        case 'medium':
          vulnerabilities.medium.push(vuln);
          break;
        default:
          vulnerabilities.low.push(vuln);
      }
      vulnerabilities.total++;
    }
  }
  
  console.log(`📊 Agente ${agentId}: ${vulnerabilities.total} vulnerabilidades encontradas (Críticas: ${vulnerabilities.critical.length}, Altas: ${vulnerabilities.high.length})`);
  
  return vulnerabilities;
}

/**
 * Guarda o actualiza vulnerabilidades en la base de datos
 */
async function saveVulnerabilityData(companyId, agentId, agentName, vulnerabilityData) {
  const client = await pool.connect();
  
  try {
    // Crear tabla si no existe
    await client.query(`
      CREATE TABLE IF NOT EXISTS agent_vulnerabilities (
        id SERIAL PRIMARY KEY,
        company_id INTEGER REFERENCES companies(id) ON DELETE CASCADE,
        agent_id VARCHAR(10) NOT NULL,
        agent_name VARCHAR(255),
        vulnerability_data JSONB NOT NULL,
        critical_count INTEGER DEFAULT 0,
        high_count INTEGER DEFAULT 0,
        medium_count INTEGER DEFAULT 0,
        low_count INTEGER DEFAULT 0,
        total_count INTEGER DEFAULT 0,
        last_scan TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(company_id, agent_id)
      )
    `);
    
    // Crear índices si no existen
    await client.query(`
      CREATE INDEX IF NOT EXISTS idx_agent_vulnerabilities_company ON agent_vulnerabilities(company_id)
    `);
    
    await client.query(`
      CREATE INDEX IF NOT EXISTS idx_agent_vulnerabilities_scan ON agent_vulnerabilities(last_scan)
    `);
    
    // Insertar o actualizar datos
    await client.query(`
      INSERT INTO agent_vulnerabilities 
      (company_id, agent_id, agent_name, vulnerability_data, critical_count, high_count, medium_count, low_count, total_count, last_scan)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, CURRENT_TIMESTAMP)
      ON CONFLICT (company_id, agent_id) 
      DO UPDATE SET
        agent_name = EXCLUDED.agent_name,
        vulnerability_data = EXCLUDED.vulnerability_data,
        critical_count = EXCLUDED.critical_count,
        high_count = EXCLUDED.high_count,
        medium_count = EXCLUDED.medium_count,
        low_count = EXCLUDED.low_count,
        total_count = EXCLUDED.total_count,
        last_scan = CURRENT_TIMESTAMP,
        updated_at = CURRENT_TIMESTAMP
    `, [
      companyId,
      agentId,
      agentName,
      JSON.stringify(vulnerabilityData),
      vulnerabilityData.critical.length,
      vulnerabilityData.high.length,
      vulnerabilityData.medium.length,
      vulnerabilityData.low.length,
      vulnerabilityData.total
    ]);
    
    console.log(`💾 Vulnerabilidades guardadas para agente ${agentId}`);
    
  } catch (error) {
    console.error(`❌ Error guardando vulnerabilidades para agente ${agentId}:`, error);
    throw error;
  } finally {
    client.release();
  }
}

/**
 * Obtiene vulnerabilidades de la base de datos (para dispositivos desconectados)
 */
async function getStoredVulnerabilities(companyId, agentId = null) {
  const client = await pool.connect();
  
  try {
    let query, params;
    
    if (agentId) {
      // Obtener vulnerabilidades de un agente específico
      query = `
        SELECT * FROM agent_vulnerabilities 
        WHERE company_id = $1 AND agent_id = $2
      `;
      params = [companyId, agentId];
    } else {
      // Obtener todas las vulnerabilidades de la empresa
      query = `
        SELECT * FROM agent_vulnerabilities 
        WHERE company_id = $1
        ORDER BY last_scan DESC
      `;
      params = [companyId];
    }
    
    const result = await client.query(query, params);
    
    return result.rows.map(row => {
      let vulnerabilityData;
      try {
        vulnerabilityData = typeof row.vulnerability_data === 'string' 
          ? JSON.parse(row.vulnerability_data) 
          : row.vulnerability_data;
      } catch (error) {
        console.error(`❌ Error parsing vulnerability data for agent ${row.agent_id}:`, error);
        vulnerabilityData = { critical: [], high: [], medium: [], low: [], total: 0 };
      }
      
      return {
        agent_id: row.agent_id,
        agent_name: row.agent_name,
        vulnerabilities: vulnerabilityData,
        counts: {
          critical: row.critical_count,
          high: row.high_count,
          medium: row.medium_count,
          low: row.low_count,
          total: row.total_count
        },
        last_scan: row.last_scan
      };
    });
    
  } catch (error) {
    console.error(`❌ Error obteniendo vulnerabilidades almacenadas:`, error);
    return [];
  } finally {
    client.release();
  }
}

/**
 * Obtiene resumen de vulnerabilidades por empresa
 */
async function getCompanyVulnerabilitySummary(companyId) {
  const client = await pool.connect();
  
  try {
    const result = await client.query(`
      SELECT 
        COUNT(*) as total_agents,
        SUM(critical_count) as total_critical,
        SUM(high_count) as total_high,
        SUM(medium_count) as total_medium,
        SUM(low_count) as total_low,
        SUM(total_count) as total_vulnerabilities,
        MAX(last_scan) as last_update
      FROM agent_vulnerabilities 
      WHERE company_id = $1
    `, [companyId]);
    
    if (result.rows.length > 0) {
      const summary = result.rows[0];
      return {
        total_agents: parseInt(summary.total_agents) || 0,
        vulnerabilities: {
          critical: parseInt(summary.total_critical) || 0,
          high: parseInt(summary.total_high) || 0,
          medium: parseInt(summary.total_medium) || 0,
          low: parseInt(summary.total_low) || 0,
          total: parseInt(summary.total_vulnerabilities) || 0
        },
        last_update: summary.last_update
      };
    }
    
    return {
      total_agents: 0,
      vulnerabilities: { critical: 0, high: 0, medium: 0, low: 0, total: 0 },
      last_update: null
    };
    
  } catch (error) {
    console.error(`❌ Error obteniendo resumen de vulnerabilidades:`, error);
    return {
      total_agents: 0,
      vulnerabilities: { critical: 0, high: 0, medium: 0, low: 0, total: 0 },
      last_update: null
    };
  } finally {
    client.release();
  }
}

module.exports = {
  analyzeAgentVulnerabilities,
  saveVulnerabilityData,
  getStoredVulnerabilities,
  getCompanyVulnerabilitySummary,
  scanPackageForVulnerabilities
};