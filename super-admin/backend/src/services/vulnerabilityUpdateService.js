const { analyzeAgentVulnerabilities, saveVulnerabilityData, getCompanyVulnerabilitySummary } = require('../utils/vulnerabilityScanner');
const pool = require('../../config/database');

/**
 * Servicio de actualizaci√≥n de vulnerabilidades en segundo plano
 * Se ejecuta cada 10 minutos para actualizar datos de vulnerabilidades
 */

// Cache de tokens de Wazuh por instalaci√≥n
let tokenCache = {
  token: null,
  expires: null
};

const WAZUH_API_URL = 'https://194.164.172.92:55000';
const WAZUH_USERNAME = 'wazuh';
const WAZUH_PASSWORD = 'wazuh';

// Funci√≥n para obtener token de Wazuh (reutilizada del controlador principal)
const getWazuhToken = async () => {
  try {
    if (tokenCache.token && tokenCache.expires && new Date() < tokenCache.expires) {
      return tokenCache.token;
    }

    const auth = Buffer.from(`${WAZUH_USERNAME}:${WAZUH_PASSWORD}`).toString('base64');
    
    const response = await fetch(`${WAZUH_API_URL}/security/user/authenticate`, {
      method: 'POST',
      headers: {
        'Authorization': `Basic ${auth}`,
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }

    const data = await response.json();
    if (data && data.data && data.data.token) {
      tokenCache.token = data.data.token;
      tokenCache.expires = new Date(Date.now() + 15 * 60 * 1000);
      return tokenCache.token;
    } else {
      throw new Error('Token inv√°lido');
    }
  } catch (error) {
    console.error('‚ùå Error obteniendo token de Wazuh:', error.message);
    tokenCache.token = null;
    tokenCache.expires = null;
    return null;
  }
};

// Funci√≥n para realizar llamadas a la API de Wazuh
const wazuhApiCall = async (endpoint) => {
  try {
    const token = await getWazuhToken();
    if (!token) {
      throw new Error('No se pudo obtener token de Wazuh');
    }

    const response = await fetch(`${WAZUH_API_URL}${endpoint}`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error(`Error en API Wazuh: ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error(`‚ùå Error en API Wazuh (${endpoint}):`, error.message);
    return null;
  }
};

/**
 * Actualiza vulnerabilidades para todos los agentes de una empresa
 */
async function updateCompanyVulnerabilities(companyId, wazuhGroup) {
  try {
    console.log(`üîÑ Iniciando actualizaci√≥n de vulnerabilidades para empresa ${companyId} (grupo: ${wazuhGroup})`);
    
    // Obtener agentes de la empresa
    const agentsResponse = await wazuhApiCall('/agents?limit=1000');
    if (!agentsResponse || !agentsResponse.data || !agentsResponse.data.affected_items) {
      console.warn(`‚ö†Ô∏è No se pudieron obtener agentes para empresa ${companyId}`);
      return false;
    }

    // Filtrar agentes por grupo de la empresa
    const companyAgents = agentsResponse.data.affected_items.filter(agent => {
      return agent.group && agent.group.includes(wazuhGroup);
    });

    if (companyAgents.length === 0) {
      console.log(`üì≠ No hay agentes para actualizar en empresa ${companyId}`);
      return true;
    }

    console.log(`üìä Actualizando vulnerabilidades para ${companyAgents.length} agentes`);
    let updatedAgents = 0;

    // Procesar cada agente
    for (const agent of companyAgents) {
      try {
        // Obtener paquetes instalados del agente
        const packagesResponse = await wazuhApiCall(`/syscollector/${agent.id}/packages?limit=1000`);
        
        if (packagesResponse && packagesResponse.data && packagesResponse.data.affected_items) {
          const packages = packagesResponse.data.affected_items;
          
          // Analizar vulnerabilidades
          const vulnerabilities = await analyzeAgentVulnerabilities(agent.id, packages);
          
          // Guardar en base de datos
          await saveVulnerabilityData(
            companyId,
            agent.id,
            agent.name || `Agent-${agent.id}`,
            vulnerabilities
          );
          
          updatedAgents++;
          console.log(`‚úÖ Agente ${agent.id} (${agent.name}) actualizado: ${vulnerabilities.total} vulnerabilidades`);
        } else {
          console.warn(`‚ö†Ô∏è No se pudieron obtener paquetes del agente ${agent.id}`);
        }
        
        // Peque√±a pausa para no sobrecargar la API
        await new Promise(resolve => setTimeout(resolve, 100));
        
      } catch (agentError) {
        console.error(`‚ùå Error procesando agente ${agent.id}:`, agentError.message);
      }
    }

    console.log(`üéâ Actualizaci√≥n completada para empresa ${companyId}: ${updatedAgents}/${companyAgents.length} agentes actualizados`);
    return true;
    
  } catch (error) {
    console.error(`‚ùå Error actualizando vulnerabilidades para empresa ${companyId}:`, error.message);
    return false;
  }
}

/**
 * Actualiza vulnerabilidades para todas las empresas
 */
async function updateAllCompaniesVulnerabilities() {
  const client = await pool.connect();
  
  try {
    console.log('üåê Iniciando actualizaci√≥n global de vulnerabilidades...');
    
    // Obtener todas las empresas
    const companiesResult = await client.query(`
      SELECT id, name, wazuh_group, tenant_id 
      FROM companies 
      WHERE wazuh_group IS NOT NULL
    `);
    
    if (companiesResult.rows.length === 0) {
      console.log('üì≠ No hay empresas configuradas para actualizar');
      return;
    }
    
    console.log(`üìä Actualizando vulnerabilidades para ${companiesResult.rows.length} empresas`);
    
    let successCount = 0;
    
    // Procesar cada empresa
    for (const company of companiesResult.rows) {
      try {
        const success = await updateCompanyVulnerabilities(company.id, company.wazuh_group);
        if (success) {
          successCount++;
        }
        
        // Pausa entre empresas para no sobrecargar el sistema
        await new Promise(resolve => setTimeout(resolve, 2000));
        
      } catch (companyError) {
        console.error(`‚ùå Error actualizando empresa ${company.name}:`, companyError.message);
      }
    }
    
    console.log(`üéâ Actualizaci√≥n global completada: ${successCount}/${companiesResult.rows.length} empresas actualizadas`);
    
  } catch (error) {
    console.error('‚ùå Error en actualizaci√≥n global de vulnerabilidades:', error.message);
  } finally {
    client.release();
  }
}

/**
 * Inicia el servicio de actualizaci√≥n autom√°tica
 */
function startVulnerabilityUpdateService() {
  console.log('üöÄ Iniciando servicio de actualizaci√≥n de vulnerabilidades (cada 10 minutos)');
  
  // Ejecutar inmediatamente la primera vez
  setTimeout(() => {
    updateAllCompaniesVulnerabilities();
  }, 30000); // Esperar 30 segundos despu√©s del inicio
  
  // Programar ejecuci√≥n cada 10 minutos
  setInterval(() => {
    updateAllCompaniesVulnerabilities();
  }, 10 * 60 * 1000); // 10 minutos
  
  console.log('‚úÖ Servicio de actualizaci√≥n de vulnerabilidades iniciado');
}

/**
 * Para el servicio de actualizaci√≥n
 */
function stopVulnerabilityUpdateService() {
  console.log('‚èπÔ∏è Deteniendo servicio de actualizaci√≥n de vulnerabilidades');
  // En una implementaci√≥n m√°s completa, aqu√≠ limpiar√≠amos intervalos espec√≠ficos
}

/**
 * Forzar actualizaci√≥n inmediata para una empresa espec√≠fica
 */
async function forceUpdateCompanyVulnerabilities(companyId) {
  const client = await pool.connect();
  
  try {
    // Obtener informaci√≥n de la empresa
    const companyResult = await client.query(`
      SELECT id, name, wazuh_group, tenant_id 
      FROM companies 
      WHERE id = $1
    `, [companyId]);
    
    if (companyResult.rows.length === 0) {
      throw new Error(`Empresa ${companyId} no encontrada`);
    }
    
    const company = companyResult.rows[0];
    console.log(`üîÑ Forzando actualizaci√≥n de vulnerabilidades para empresa: ${company.name}`);
    
    return await updateCompanyVulnerabilities(company.id, company.wazuh_group);
    
  } catch (error) {
    console.error(`‚ùå Error en actualizaci√≥n forzada:`, error.message);
    return false;
  } finally {
    client.release();
  }
}

module.exports = {
  startVulnerabilityUpdateService,
  stopVulnerabilityUpdateService,
  updateCompanyVulnerabilities,
  updateAllCompaniesVulnerabilities,
  forceUpdateCompanyVulnerabilities
};